
/*
Постоји неколико мера које одређују средину дате серије бројева. Најпознатија је аритметичка средина тј. просек, међутим, она је 
прилично осетљива на грешке у подацима и неколико елемената који значајно одступају од осталих могу прилично да измене просек. 
На пример, просек бројева 3, 2, 1, 5, 4 је 3, међутим, ако им се дода број 99, тада просек постаје око 19, што је јако велика промена 
настала под утицајем само једног елемента, који може бити и резултат неке грешке у подацима. Зато се често разматра медијана која 
се добија тако што се низ сортира и посматра се средишњи елемент (ако је укупан број елемената непаран), 
тј. просек два средишња елемента (ако је укупан број елемената паран). На пример, ако се наша полазна серија сортира добија 
се 1, 2, 3, 4, 5 и ту је средишњи елемент 3 и он је уједно и медијана, а ако се придода и 99, тада су два средишња елемента 3 и 4 и 
медијана је 3,5. Напиши функцију која одређује медијану дате серије бројева.
Израчунавање медијане ћемо тестирати тако што ћемо га применити на серију бројева која се добија тако што се примени рекурентна 
формула ai+1=c0⋅ai+c1, почевши од задатог елемента a0. На пример, ако је a0=0,c0=4 i c1=1, добија се серија,1,5,21,85,…. При 
том се сва аритметика изводи са неозначеним бројевима, по модулу 232

Ulaz:
У првој линији стандардног улаза налази се број n који представља број елемената серије чију медијану треба израчунати
. У другој бројеви c0,c1, раздвојени са по једним размаком. У трећој линији се налази се број a0.

Izlaz:
На стандардни излаз исписати вредност медијане заокружене на 2 децимале.

*/

#include<iostream>
#include<vector>
#include<iomanip>
#include<algorithm>

using namespace std;

float quickselect(vector<float> &v, int num, int l, int d){
    int p = l;
    for(int i = l + 1; i < d; i++)
        if(v[i] < v[l])
            swap(v[i],v[++p]);
    swap(v[l],v[p]);

    if(p < num){
        return quickselect(v, num, p + 1, d); 
    }
    else if(p > num){
        return quickselect(v, num, l, p);
    }
    else{
        return v[p];
    }
}


float medijana(vector<float> &v, int n){
    if(v.size() % 2 != 0){
        return quickselect(v, v.size() / 2, 0, v.size() - 1);
    }
    else {
        return (quickselect(v, v.size() / 2, 0, v.size() - 1) + quickselect(v, v.size() / 2 + 1, 0, v.size() - 1)) / 2; 
    }
}

int main(){

    int n, a0, c0, c1;
    cin >> n;
    cin >> c0 >> c1;
    cin >> a0;
    vector<float> v(n);
    v[0] = a0; 

    for(int i = 1; i < n; i++){
        v[i] = c0*v[i - 1] + c1;
    }

    cout << fixed << showpoint << setprecision(2) << medijana(v, n) << '\n';

    exit(EXIT_SUCCESS);
}